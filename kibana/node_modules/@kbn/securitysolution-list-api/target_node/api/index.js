"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.updateExceptionListItem = exports.updateExceptionList = exports.fetchExceptionListsItemsByListIds = exports.fetchExceptionLists = exports.fetchExceptionListItemById = exports.fetchExceptionListById = exports.exportExceptionList = exports.deleteExceptionListItemById = exports.deleteExceptionListById = exports.addExceptionListItem = exports.addExceptionList = exports.addEndpointExceptionList = void 0;

var _TaskEither = require("fp-ts/lib/TaskEither");

var _function = require("fp-ts/lib/function");

var _securitysolutionIoTsUtils = require("@kbn/securitysolution-io-ts-utils");

var _securitysolutionIoTsListTypes = require("@kbn/securitysolution-io-ts-list-types");

var _securitysolutionListConstants = require("@kbn/securitysolution-list-constants");

var _fp_utils = require("../fp_utils");

/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0 and the Server Side Public License, v 1; you may not use this file except
 * in compliance with, at your election, the Elastic License 2.0 or the Server
 * Side Public License, v 1.
 */

/**
 * Add new ExceptionList
 *
 * @param http Kibana http service
 * @param list exception list to add
 * @param signal to cancel request
 *
 * @throws An error if response is not OK
 *
 */
const addExceptionList = async ({
  http,
  list,
  signal
}) => http.fetch(_securitysolutionListConstants.EXCEPTION_LIST_URL, {
  body: JSON.stringify(list),
  method: 'POST',
  signal
});

const addExceptionListWithValidation = async ({
  http,
  list,
  signal
}) => (0, _function.flow)(() => (0, _TaskEither.tryCatch)(() => addExceptionList({
  http,
  list,
  signal
}), _fp_utils.toError), (0, _TaskEither.chain)(response => (0, _TaskEither.fromEither)((0, _securitysolutionIoTsUtils.validateEither)(_securitysolutionIoTsListTypes.exceptionListSchema, response))), (0, _function.flow)(_fp_utils.toPromise))();

exports.addExceptionList = addExceptionListWithValidation;

/**
 * Add new ExceptionListItem
 *
 * @param http Kibana http service
 * @param listItem exception list item to add
 * @param signal to cancel request
 *
 * @throws An error if response is not OK
 *
 */
const addExceptionListItem = async ({
  http,
  listItem,
  signal
}) => http.fetch(_securitysolutionListConstants.EXCEPTION_LIST_ITEM_URL, {
  body: JSON.stringify(listItem),
  method: 'POST',
  signal
});

const addExceptionListItemWithValidation = async ({
  http,
  listItem,
  signal
}) => (0, _function.flow)(() => (0, _TaskEither.tryCatch)(() => addExceptionListItem({
  http,
  listItem,
  signal
}), _fp_utils.toError), (0, _TaskEither.chain)(response => (0, _TaskEither.fromEither)((0, _securitysolutionIoTsUtils.validateEither)(_securitysolutionIoTsListTypes.exceptionListItemSchema, response))), (0, _function.flow)(_fp_utils.toPromise))();

exports.addExceptionListItem = addExceptionListItemWithValidation;

/**
 * Update existing ExceptionList
 *
 * @param http Kibana http service
 * @param list exception list to add
 * @param signal to cancel request
 *
 * @throws An error if response is not OK
 *
 */
const updateExceptionList = async ({
  http,
  list,
  signal
}) => http.fetch(_securitysolutionListConstants.EXCEPTION_LIST_URL, {
  body: JSON.stringify(list),
  method: 'PUT',
  signal
});

const updateExceptionListWithValidation = async ({
  http,
  list,
  signal
}) => (0, _function.flow)(() => (0, _TaskEither.tryCatch)(() => updateExceptionList({
  http,
  list,
  signal
}), _fp_utils.toError), (0, _TaskEither.chain)(response => (0, _TaskEither.fromEither)((0, _securitysolutionIoTsUtils.validateEither)(_securitysolutionIoTsListTypes.exceptionListSchema, response))), (0, _function.flow)(_fp_utils.toPromise))();

exports.updateExceptionList = updateExceptionListWithValidation;

/**
 * Update existing ExceptionListItem
 *
 * @param http Kibana http service
 * @param listItem exception list item to add
 * @param signal to cancel request
 *
 * @throws An error if response is not OK
 *
 */
const updateExceptionListItem = async ({
  http,
  listItem,
  signal
}) => http.fetch(_securitysolutionListConstants.EXCEPTION_LIST_ITEM_URL, {
  body: JSON.stringify(listItem),
  method: 'PUT',
  signal
});

const updateExceptionListItemWithValidation = async ({
  http,
  listItem,
  signal
}) => (0, _function.flow)(() => (0, _TaskEither.tryCatch)(() => updateExceptionListItem({
  http,
  listItem,
  signal
}), _fp_utils.toError), (0, _TaskEither.chain)(response => (0, _TaskEither.fromEither)((0, _securitysolutionIoTsUtils.validateEither)(_securitysolutionIoTsListTypes.exceptionListItemSchema, response))), (0, _function.flow)(_fp_utils.toPromise))();

exports.updateExceptionListItem = updateExceptionListItemWithValidation;

/**
 * Fetch all ExceptionLists (optionally by namespaceType)
 *
 * @param http Kibana http service
 * @param namespaceTypes ExceptionList namespace_types of lists to find
 * @param filters search bar filters
 * @param pagination optional
 * @param signal to cancel request
 *
 * @throws An error if request params or response is not OK
 */
const fetchExceptionLists = async ({
  http,
  filters,
  namespaceTypes,
  pagination,
  signal
}) => {
  const query = {
    filter: filters || undefined,
    namespace_type: namespaceTypes,
    page: pagination.page ? `${pagination.page}` : '1',
    per_page: pagination.perPage ? `${pagination.perPage}` : '20',
    sort_field: 'exception-list.created_at',
    sort_order: 'desc'
  };
  return http.fetch(`${_securitysolutionListConstants.EXCEPTION_LIST_URL}/_find`, {
    method: 'GET',
    query,
    signal
  });
};

const fetchExceptionListsWithValidation = async ({
  filters,
  http,
  namespaceTypes,
  pagination,
  signal
}) => (0, _function.flow)(() => (0, _TaskEither.tryCatch)(() => fetchExceptionLists({
  filters,
  http,
  namespaceTypes,
  pagination,
  signal
}), _fp_utils.toError), (0, _TaskEither.chain)(response => (0, _TaskEither.fromEither)((0, _securitysolutionIoTsUtils.validateEither)(_securitysolutionIoTsListTypes.foundExceptionListSchema, response))), (0, _function.flow)(_fp_utils.toPromise))();

exports.fetchExceptionLists = fetchExceptionListsWithValidation;

/**
 * Fetch an ExceptionList by providing a ExceptionList ID
 *
 * @param http Kibana http service
 * @param id ExceptionList ID (not list_id)
 * @param namespaceType ExceptionList namespace_type
 * @param signal to cancel request
 *
 * @throws An error if response is not OK
 */
const fetchExceptionListById = async ({
  http,
  id,
  namespaceType,
  signal
}) => http.fetch(_securitysolutionListConstants.EXCEPTION_LIST_URL, {
  method: 'GET',
  query: {
    id,
    namespace_type: namespaceType
  },
  signal
});

const fetchExceptionListByIdWithValidation = async ({
  http,
  id,
  namespaceType,
  signal
}) => (0, _function.flow)(() => (0, _TaskEither.tryCatch)(() => fetchExceptionListById({
  http,
  id,
  namespaceType,
  signal
}), _fp_utils.toError), (0, _TaskEither.chain)(response => (0, _TaskEither.fromEither)((0, _securitysolutionIoTsUtils.validateEither)(_securitysolutionIoTsListTypes.exceptionListSchema, response))), (0, _function.flow)(_fp_utils.toPromise))();

exports.fetchExceptionListById = fetchExceptionListByIdWithValidation;

/**
 * Fetch an ExceptionList's ExceptionItems by providing a ExceptionList list_id
 *
 * @param http Kibana http service
 * @param listIds ExceptionList list_ids (not ID)
 * @param namespaceTypes ExceptionList namespace_types
 * @param filterOptions optional - filter by field or tags
 * @param pagination optional
 * @param signal to cancel request
 *
 * @throws An error if response is not OK
 */
const fetchExceptionListsItemsByListIds = async ({
  http,
  listIds,
  namespaceTypes,
  filterOptions,
  pagination,
  signal
}) => {
  const filters = filterOptions.map((filter, index) => {
    const namespace = namespaceTypes[index];
    const filterNamespace = namespace === 'agnostic' ? _securitysolutionListConstants.EXCEPTION_LIST_NAMESPACE_AGNOSTIC : _securitysolutionListConstants.EXCEPTION_LIST_NAMESPACE;
    const formattedFilters = [...(filter.filter.length ? [`${filterNamespace}.attributes.entries.field:${filter.filter}*`] : []), ...(filter.tags.length ? filter.tags.map(t => `${filterNamespace}.attributes.tags:${t}`) : [])];
    return formattedFilters.join(' AND ');
  }).join(',');
  const query = {
    list_id: listIds.join(','),
    namespace_type: namespaceTypes.join(','),
    page: pagination.page ? `${pagination.page}` : '1',
    per_page: pagination.perPage ? `${pagination.perPage}` : '20',
    sort_field: 'exception-list.created_at',
    sort_order: 'desc',
    ...(filters.trim() !== '' ? {
      filter: filters
    } : {})
  };
  return http.fetch(`${_securitysolutionListConstants.EXCEPTION_LIST_ITEM_URL}/_find`, {
    method: 'GET',
    query,
    signal
  });
};

const fetchExceptionListsItemsByListIdsWithValidation = async ({
  filterOptions,
  http,
  listIds,
  namespaceTypes,
  pagination,
  signal
}) => (0, _function.flow)(() => (0, _TaskEither.tryCatch)(() => fetchExceptionListsItemsByListIds({
  filterOptions,
  http,
  listIds,
  namespaceTypes,
  pagination,
  signal
}), _fp_utils.toError), (0, _TaskEither.chain)(response => (0, _TaskEither.fromEither)((0, _securitysolutionIoTsUtils.validateEither)(_securitysolutionIoTsListTypes.foundExceptionListItemSchema, response))), (0, _function.flow)(_fp_utils.toPromise))();

exports.fetchExceptionListsItemsByListIds = fetchExceptionListsItemsByListIdsWithValidation;

/**
 * Fetch an ExceptionListItem by providing a ExceptionListItem ID
 *
 * @param http Kibana http service
 * @param id ExceptionListItem ID (not item_id)
 * @param namespaceType ExceptionList namespace_type
 * @param signal to cancel request
 *
 * @throws An error if response is not OK
 */
const fetchExceptionListItemById = async ({
  http,
  id,
  namespaceType,
  signal
}) => http.fetch(_securitysolutionListConstants.EXCEPTION_LIST_ITEM_URL, {
  method: 'GET',
  query: {
    id,
    namespace_type: namespaceType
  },
  signal
});

const fetchExceptionListItemByIdWithValidation = async ({
  http,
  id,
  namespaceType,
  signal
}) => (0, _function.flow)(() => (0, _TaskEither.tryCatch)(() => fetchExceptionListItemById({
  http,
  id,
  namespaceType,
  signal
}), _fp_utils.toError), (0, _TaskEither.chain)(response => (0, _TaskEither.fromEither)((0, _securitysolutionIoTsUtils.validateEither)(_securitysolutionIoTsListTypes.exceptionListItemSchema, response))), (0, _function.flow)(_fp_utils.toPromise))();

exports.fetchExceptionListItemById = fetchExceptionListItemByIdWithValidation;

/**
 * Delete an ExceptionList by providing a ExceptionList ID
 *
 * @param http Kibana http service
 * @param id ExceptionList ID (not list_id)
 * @param namespaceType ExceptionList namespace_type
 * @param signal to cancel request
 *
 * @throws An error if response is not OK
 */
const deleteExceptionListById = async ({
  http,
  id,
  namespaceType,
  signal
}) => http.fetch(_securitysolutionListConstants.EXCEPTION_LIST_URL, {
  method: 'DELETE',
  query: {
    id,
    namespace_type: namespaceType
  },
  signal
});

const deleteExceptionListByIdWithValidation = async ({
  http,
  id,
  namespaceType,
  signal
}) => (0, _function.flow)(() => (0, _TaskEither.tryCatch)(() => deleteExceptionListById({
  http,
  id,
  namespaceType,
  signal
}), _fp_utils.toError), (0, _TaskEither.chain)(response => (0, _TaskEither.fromEither)((0, _securitysolutionIoTsUtils.validateEither)(_securitysolutionIoTsListTypes.exceptionListSchema, response))), (0, _function.flow)(_fp_utils.toPromise))();

exports.deleteExceptionListById = deleteExceptionListByIdWithValidation;

/**
 * Delete an ExceptionListItem by providing a ExceptionListItem ID
 *
 * @param http Kibana http service
 * @param id ExceptionListItem ID (not item_id)
 * @param namespaceType ExceptionList namespace_type
 * @param signal to cancel request
 *
 * @throws An error if response is not OK
 */
const deleteExceptionListItemById = async ({
  http,
  id,
  namespaceType,
  signal
}) => http.fetch(_securitysolutionListConstants.EXCEPTION_LIST_ITEM_URL, {
  method: 'DELETE',
  query: {
    id,
    namespace_type: namespaceType
  },
  signal
});

const deleteExceptionListItemByIdWithValidation = async ({
  http,
  id,
  namespaceType,
  signal
}) => (0, _function.flow)(() => (0, _TaskEither.tryCatch)(() => deleteExceptionListItemById({
  http,
  id,
  namespaceType,
  signal
}), _fp_utils.toError), (0, _TaskEither.chain)(response => (0, _TaskEither.fromEither)((0, _securitysolutionIoTsUtils.validateEither)(_securitysolutionIoTsListTypes.exceptionListItemSchema, response))), (0, _function.flow)(_fp_utils.toPromise))();

exports.deleteExceptionListItemById = deleteExceptionListItemByIdWithValidation;

/**
 * Add new Endpoint ExceptionList
 *
 * @param http Kibana http service
 * @param signal to cancel request
 *
 * @throws An error if response is not OK
 *
 */
const addEndpointExceptionList = async ({
  http,
  signal
}) => http.fetch(_securitysolutionListConstants.ENDPOINT_LIST_URL, {
  method: 'POST',
  signal
});

const addEndpointExceptionListWithValidation = async ({
  http,
  signal
}) => (0, _function.flow)(() => (0, _TaskEither.tryCatch)(() => addEndpointExceptionList({
  http,
  signal
}), _fp_utils.toError), (0, _TaskEither.chain)(response => (0, _TaskEither.fromEither)((0, _securitysolutionIoTsUtils.validateEither)(_securitysolutionIoTsListTypes.createEndpointListSchema, response))), (0, _function.flow)(_fp_utils.toPromise))();

exports.addEndpointExceptionList = addEndpointExceptionListWithValidation;

/**
 * Fetch an ExceptionList by providing a ExceptionList ID
 *
 * @param http Kibana http service
 * @param id ExceptionList ID (not list_id)
 * @param listId ExceptionList LIST_ID (not id)
 * @param namespaceType ExceptionList namespace_type
 * @param signal to cancel request
 *
 * @throws An error if response is not OK
 */
const exportExceptionList = async ({
  http,
  id,
  listId,
  namespaceType,
  signal
}) => http.fetch(`${_securitysolutionListConstants.EXCEPTION_LIST_URL}/_export`, {
  method: 'POST',
  query: {
    id,
    list_id: listId,
    namespace_type: namespaceType
  },
  signal
});

exports.exportExceptionList = exportExceptionList;